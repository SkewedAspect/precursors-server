#!/bin/bash
# 
# Rebar does not allow for an easy way to change a system that's running.  
# Generating a release does a fine job of creating a start up script, but 
# it cannot be regenerated without trashing the existing release.  The bins 
# for the deps are not put into the primary ebin folder, so those get lost. 
# Thus, this is a dev boot script that will allow one to start the system 
# in a dev-friendly mode, and still be able to run rebar and reload the 
# resulting code.  If the default boot file is not present, it will try to 
# make it.

function help_dump {
	echo "usage:  devboot [-c cookiename] [-s shortname | -n longname] [-f configfile] [-e erl_shell] [-nb | -b bootfile]"
	echo ""
	echo "-c defaults to \"PreServDev\""
	echo "-s and -n override each other.  Defaults to \"-s precursors_server_dev\""
	echo "-b defaults to rel/precursors_server/releases/1/precursors_server"
	echo "-nb disables use of a boot file.  -b and -nb override each other."
	echo "-f defaults to \"single\""
	echo "-e defaults to \"erl\""
}

EBIN="ebin"
COOKIE="PreServDev"
NAMETYPE="-sname"
NODENAME="precursors_server_dev"
CONFIG="single"
BOOT="-boot rel/precursors_server/releases/1/precursors_server"
ERL_PATH="erl"

PRECURSORS_SERVER_RUN_DIR="rel/precursors_server/run"
export PRECURSORS_SERVER_RUN_DIR

deps=`ls deps`
morepa=""

for deps_dir in $deps
do
	morepa="$morepa -pa deps/$deps_dir/ebin"
done
# and included apps too
included_apps=`ls included_apps`
for included_app_dir in $included_apps
do
	morepa="$morepa -pa included_apps/$included_app_dir/ebin"
done

if [ ! -f "rel/precursors_server/releases/1/precursors_server.boot" ]
then
    echo "Generating default boot file..."
    ./rebar generate
fi

args=("$@")
argstring=""
i=0
while [ $i -lt ${#args[@]} ]
do
	case ${args[${i}]} in
		"-s")
			NAMETYPE="-sname"
			let i=$i+1
			NODENAME="${args[${i}]}";;
		"-n")
			NAMETYPE="-name"
			let i=$i+1
			NODENAME="${args[${i}]}";;
		"-b")
			let i=$i+1
			BOOT="-boot ${args[${i}]}";;
		"-nb")
			BOOT="";;
		"-c")
			let i=$i+1
			COOKIE="${args[${i}]}";;
		"-f")
			let i=$i+1
			CONFIG="${args[${i}]}";;
		"-e")
			let i=$i+1
			ERL_PATH="${args[${i}]}";;
		*)
			help_dump
			exit 0
	esac
	argstring="$argstring ${args[${i}]}"
	let i=$i+1
done

if [ ! -f $CONFIG ] && [ ! -f "${CONFIG}.config" ]; then
	SUFFIX=`echo "${CONFIG}" | awk -F . '{print $NF}'`
	CONFIGNODENAME=`erl -eval "io:format(\"~s\",[node()]),halt(1)" $NAMETYPE $NODENAME -noshell`
	if [ $SUFFIX = 'config' ]; then
		FILE=$CONFIG
	else
		FILE="${CONFIG}.config"
	fi
	cat > $FILE <<single.config
%% This file was generated by devboot.
%% If you are comfortable editing erlang application configuration scripts
%% there is no harm in editing the file.
[{'precursors_server', [
	{nodes, ['$CONFIGNODENAME']},
	{auth_backends, [
		{config_auth, 2, [{allow, ["user"]}]}
	]}
]},

{'lager', [
	{handlers, [
		{lager_console_backend, [info,true]},
		{lager_file_backend, [
			{"debug.log", debug, 10485760, "$D0", 5}
		]}
	]},
	{crash_log, "crash.log"}
]},

{sasl, [
	{errlog_type, error} % disable SASL progress reports
]}].

% vim: ft=erlang
single.config
fi

if [ ! -f "priv/key" ]; then
	echo "RSA key does not exist, generating..."
	ssh-keygen -t rsa -f priv/key -N ""
	RES=$?
	if [ $RES != 0 ]; then
		echo "Key generation failed with error $RES!"
		exit $RES
	fi
fi

export PRECURSORS_SERVER_RUN_DIR=`pwd`

CMD="$ERL_PATH +K true -pa $EBIN $morepa -setcookie $COOKIE $NAMETYPE $NODENAME -config $CONFIG $BOOT"

#echo $CMD
exec $CMD

exit 0
